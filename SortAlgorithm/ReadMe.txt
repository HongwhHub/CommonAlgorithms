
对数器
	生成随机长度的数组，内容随机，使用系统自带的绝对正确的函数对生成的数组进行排序，将系统排序后的数组与
 自己的排序算法排后的数组进行比对，输出OK则代表排序正确。

递归行为和递归行为时间复杂度的估算
master公式的使用:(划分子问题规模一样)
T(N) = a*T(N/b) + O(N^d)
1) log(b,a) > d -> 复杂度为O(N^log(b,a))
2) log(b,a) = d -> 复杂度为O(N^d * logN)
3) log(b,a) < d -> 复杂度为O(N^d)


1. 冒泡排序 O（N²）
   2 4 1 3 9
   当 end=4 时
      2和4进行比较 4比2大 -> 4 2 1 3 9		i=0
	  2与1进行比较 1比2小 -> 4 2 1 3 9		i=1
	  1与3进行比较 3比1大 -> 4 2 3 1 9		i=2
	  1与9进行比较 9比1大 -> 4 2 3 9 1		i=3
   当end =3 时
	  4和2进行比较 4比2大 -> 4 2 3 9 1		i=0
	  2与3进行比较 3比2大 -> 4 3 2 9 1		i=1
	  2与9进行比较 9比2大 -> 4 3 9 2 1		i=2
   当end =2 时
	  4和2进行比较 4比3大 -> 4 3 9 2 1		i=0
	  3与9进行比较 9比3大 -> 4 9 3 2 1		i=1
   当end =1 时
	  4和9进行比较 9比4大 -> 9 4 3 2 1		i=0
   排序结束

2. 选择排序 O（N²）
   2 4 1 3 9
   当 i=0 时 
      maxIndex=0 
	  2和4进行比较 4比2大 -> maxIndex=1    j=1
	  1和4进行比较 4比1大 -> maxIndex=1    j=2
	  3和4进行比较 4比3大 -> maxIndex=1    j=3
	  9和4进行比较 9比4大 -> maxIndex=4    j=4
	  交换0和4位置的数 -> 9 4 1 3 2
   当 i=1 时 
      maxIndex=1 
	  1和4进行比较 4比1大 -> maxIndex=1    j=2
	  3和4进行比较 4比3大 -> maxIndex=1    j=3
	  3和4进行比较 4比2大 -> maxIndex=1    j=4
	  交换1和1位置的数 -> 9 4 1 3 2
   当 i=2 时 
      maxIndex=2 
	  1和3进行比较 3比1大 -> maxIndex=3    j=3
	  3和2进行比较 3比2大 -> maxIndex=3    j=4
	  交换2和3位置的数 -> 9 4 3 1 2
   当 i=3 时 
      maxIndex=3 
	  1和2进行比较 2比1大 -> maxIndex=4    j=4
	  交换3和4位置的数 -> 9 4 3 2 1
   排序结束

3 插入排序 复杂度 O（N²)（以降序为例，若数组本身有序，则是O(N),若是逆序，则是O（N²))
   2 4 1 3 9
   当 i=1 时
   4与2进行比较 4比2大 ->4 2 1 3 9
   当 i=2 时
   1与2进行比较 1比2小 不交换位置
   当 i=3 时
   3与1进行比较 3比1大 -> 4 2 3 1 9
   3与2进行比较 3比2大 -> 4 3 2 1 9
   3与4进行比较 3比4小 不交换位置
   当 i=4时
   9与1进行比较 9比1大 -> 4 2 3 9 1
   9与3进行比较 9比3大 -> 4 2 9 3 1
   9与2进行比较 9比2大 -> 4 9 3 2 1
   9与4进行比较 9比4大 -> 9 4 3 2 1
   排序结束

4 归并排序 复杂度 O(N*logN)
   2 4 1 5 3 8
   先将数组分成左右两部分，对左右两部分进行排序
   左：2 4 1
      分成左右两部分
	    左 2 
		  只有一个数，不需要排序
		右 4 1
		  辅助数组 tmp
		  下标 p1指向4 p2指向1， 4比1大，tmp[0]=4，tmp[1]=1
      辅助数组 tmp
	    下标 p1指向2 p2指向4，4比2大，tmp[0]=4,
		下标 p1指向2,p2指向1，2比1大，tmp[1]=2,
		tmp[2]=1;
	左边排序结束 4 2 1 
	右：5 3 8
      分成左右两部分
	    左 5 
		  只有一个数，不需要排序
		右 3 8
		  辅助数组 tmp
		  下标 p1指向3 p2指向8， 8比3大，tmp[0]=8，tmp[1]=3 
      辅助数组 tmp
	    下标 p1指向5 p2指向8，8比5大，tmp[0]=8,
		下标 p1指向5,p2指向3，5比3大，tmp[1]=5,
		tmp[2]=3;
	右边排序结束 8 5 3
	这时候数组变成 4 2 1 8 5 3
	辅助数组 tmp
	下标 p1指向4 p2指向8，8比4大，tmp[0]=8,
	下标 p1指向4,p2指向5，5比4大，tmp[1]=5,
	下标 p1指向4,p2指向3，4比3大，tmp[2]=4,
	下标 p1指向2,p2指向3，3比2大，tmp[3]=3,
	p2越界，直接将p1剩下的拷贝到tmp之后 tmp[4]=2,tmp[5]=1
	归并排序结束
	  
     
